<GENERATED-CODE>
Here are the step-by-step instructions to begin implementing the recommendations.

1.  **Update `ContentGenerationService.php`**: Modify the `combineGenerationResults` method to add a unique `id` to each suggestion. This is critical for fixing the feedback loop.
2.  **Update `ContentGenerationController.php`**: Adjust the `submitContentFeedback` validation to expect the new `suggestion_id` and log it.
3.  **Update `AIProfileBuilder.tsx`**: Change the `handleFeedback` call to pass the new `suggestion.id` instead of the full text content.

<UPDATED_EXISTING_FILE: app/Services/ContentGenerationService.php>
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use App\Models\User;
use App\Models\BulletinBoard;
use App\Models\BulletinMessage;
use Illuminate\Support\Str;

class ContentGenerationService
{
    private string $openaiApiKey;
    private string $geminiApiKey;
    private array $generationConfig;

    public function __construct()
    {
        $this->openaiApiKey = config('services.openai.api_key');
        $this->geminiApiKey = config('services.gemini.api_key');
        $this->generationConfig = config('content_generation', [
            'enabled' => true,
            'providers' => ['openai', 'gemini'],
            'max_tokens' => 1000,
            'temperature' => 0.7,
            'cache_ttl' => 3600,
            'safety_threshold' => 0.8,
        ]);
    }

    /**
     * Generate personalized profile content
     */
    public function generateProfileContent(User $user, array $preferences = []): array
    {
        $cacheKey = "profile_content_{$user->id}_" . md5(serialize($preferences));
        
        if ($cached = Cache::get($cacheKey)) {
            return $cached;
        }

        $userProfile = $this->buildUserProfile($user);
        $context = $this->buildProfileContext($preferences);
        
        $content = $this->generateWithMultiAI($userProfile, $context, 'profile');
        
        Cache::put($cacheKey, $content, $this->generationConfig['cache_ttl']);
        
        return $content;
    }

    /**
     * Generate bulletin board post suggestions
     */
    public function generatePostSuggestions(BulletinBoard $board, User $user, array $context = []): array
    {
        $boardContext = $this->buildBoardContext($board);
        $userContext = $this->buildUserContext($user);
        $locationContext = $this->buildLocationContext($board, $user);
        
        $combinedContext = array_merge($boardContext, $userContext, $locationContext, $context);
        
        return $this->generateWithMultiAI($combinedContext, $context, 'post_suggestions');
    }

    /**
     * Generate conversation starters
     */
    public function generateConversationStarters(User $user, array $context = []): array
    {
        $userContext = $this->buildUserContext($user);
        $conversationContext = $this->buildConversationContext($context);
        
        $combinedContext = array_merge($userContext, $conversationContext);
        
        return $this->generateWithMultiAI($combinedContext, $context, 'conversation_starters');
    }

    /**
     * Generate content with multiple AI providers
     */
    private function generateWithMultiAI(array $context, array $additionalContext, string $type): array
    {
        $results = [];
        
        // OpenAI generation
        if (in_array('openai', $this->generationConfig['providers'])) {
            $results['openai'] = $this->generateWithOpenAI($context, $additionalContext, $type);
        }
        
        // Gemini generation
        if (in_array('gemini', $this->generationConfig['providers'])) {
            $results['gemini'] = $this->generateWithGemini($context, $additionalContext, $type);
        }
        
        // Combine and rank results
        return $this->combineGenerationResults($results, $type);
    }

    /**
     * Generate content with OpenAI
     */
    private function generateWithOpenAI(array $context, array $additionalContext, string $type): array
    {
        try {
            $prompt = $this->buildOpenAIPrompt($context, $additionalContext, $type);
            
            $response = Http::withHeaders([
                'Authorization' => 'Bearer ' . $this->openaiApiKey,
                'Content-Type' => 'application/json',
            ])->post('https://api.openai.com/v1/chat/completions', [
                'model' => 'gpt-4',
                'messages' => [
                    ['role' => 'system', 'content' => $this->getSystemPrompt($type)],
                    ['role' => 'user', 'content' => $prompt]
                ],
                'max_tokens' => $this->generationConfig['max_tokens'],
                'temperature' => $this->generationConfig['temperature'],
            ]);

            if ($response->successful()) {
                $data = $response->json();
                $content = $data['choices'][0]['message']['content'] ?? '';
                
                return [
                    'content' => $content,
                    'provider' => 'openai',
                    'confidence' => $this->calculateConfidence($content),
                    'safety_score' => $this->calculateSafetyScore($content),
                ];
            }
        } catch (\Exception $e) {
            Log::error('OpenAI content generation failed', ['error' => $e->getMessage()]);
        }

        return ['content' => '', 'error' => 'OpenAI generation unavailable'];
    }

    /**
     * Generate content with Gemini
     */
    private function generateWithGemini(array $context, array $additionalContext, string $type): array
    {
        try {
            $prompt = $this->buildGeminiPrompt($context, $additionalContext, $type);
            
            $response = Http::withHeaders([
                'Content-Type' => 'application/json',
            ])->post("https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key={$this->geminiApiKey}", [
                'contents' => [
                    [
                        'parts' => [
                            ['text' => $prompt]
                        ]
                    ]
                ],
                'generationConfig' => [
                    'temperature' => $this->generationConfig['temperature'],
                    'maxOutputTokens' => $this->generationConfig['max_tokens'],
                ]
            ]);

            if ($response->successful()) {
                $data = $response->json();
                $content = $data['candidates'][0]['content']['parts'][0]['text'] ?? '';
                
                return [
                    'content' => $content,
                    'provider' => 'gemini',
                    'confidence' => $this->calculateConfidence($content),
                    'safety_score' => $this->calculateSafetyScore($content),
                ];
            }
        } catch (\Exception $e) {
            Log::error('Gemini content generation failed', ['error' => $e->getMessage()]);
        }

        return ['content' => '', 'error' => 'Gemini generation unavailable'];
    }

    /**
     * Build user profile for content generation
     */
    private function buildUserProfile(User $user): array
    {
        return [
            'id' => $user->id,
            'name' => $user->name,
            'age' => $user->age,
            'interests' => $user->interests ?? [],
            'personality_traits' => $this->analyzePersonalityTraits($user),
            'communication_style' => $this->analyzeCommunicationStyle($user),
            'location' => [
                'latitude' => $user->latitude,
                'longitude' => $user->longitude,
            ],
            'activity_level' => $this->calculateActivityLevel($user),
            'engagement_patterns' => $this->analyzeEngagementPatterns($user),
        ];
    }

    /**
     * Build board context for content generation
     */
    private function buildBoardContext(BulletinBoard $board): array
    {
        return [
            'id' => $board->id,
            'name' => $board->name,
            'description' => $board->description,
            'location' => [
                'latitude' => $board->center_lat,
                'longitude' => $board->center_lng,
            ],
            'recent_activity' => $this->getRecentBoardActivity($board),
            'popular_topics' => $this->getPopularBoardTopics($board),
            'user_demographics' => $this->getBoardUserDemographics($board),
        ];
    }

    /**
     * Build user context for content generation
     */
    private function buildUserContext(User $user): array
    {
        return [
            'user_id' => $user->id,
            'name' => $user->name,
            'interests' => $user->interests ?? [],
            'personality' => $this->analyzePersonalityTraits($user),
            'communication_style' => $this->analyzeCommunicationStyle($user),
            'activity_level' => $this->calculateActivityLevel($user),
        ];
    }

    /**
     * Build location context
     */
    private function buildLocationContext(BulletinBoard $board, User $user): array
    {
        return [
            'board_location' => [
                'latitude' => $board->center_lat,
                'longitude' => $board->center_lng,
            ],
            'user_location' => [
                'latitude' => $user->latitude,
                'longitude' => $user->longitude,
            ],
            'distance' => $this->calculateDistance(
                $user->latitude, $user->longitude,
                $board->center_lat, $board->center_lng
            ),
        ];
    }

    /**
     * Build conversation context
     */
    private function buildConversationContext(array $context): array
    {
        return [
            'conversation_type' => $context['type'] ?? 'general',
            'target_user' => $context['target_user'] ?? null,
            'previous_messages' => $context['previous_messages'] ?? [],
            'context_hints' => $context['hints'] ?? [],
        ];
    }

    /**
     * Build profile context
     */
    private function buildProfileContext(array $preferences): array
    {
        return [
            'personality_type' => $preferences['personality'] ?? '',
            'interests' => $preferences['interests'] ?? [],
            'goals' => $preferences['goals'] ?? '',
            'style' => $preferences['style'] ?? 'casual',
            'target_audience' => $preferences['target_audience'] ?? 'general',
        ];
    }

    /**
     * Combine generation results from multiple providers
     */
    private function combineGenerationResults(array $results, string $type): array
    {
        $validResults = array_filter($results, fn($r) => !empty($r['content']) && !isset($r['error']));
        
        if (empty($validResults)) {
            return ['suggestions' => [], 'error' => 'No valid content generated'];
        }

        $suggestions = [];
        foreach ($validResults as $provider => $result) {
            $suggestions[] = [
                'id' => (string) Str::uuid(), // Add a unique ID for each suggestion
                'content' => $result['content'],
                'provider' => $provider,
                'confidence' => $result['confidence'],
                'safety_score' => $result['safety_score'],
                'type' => $type,
                'timestamp' => now()->toISOString(),
            ];
        }

        // Sort by confidence and safety score
        usort($suggestions, function($a, $b) {
            $scoreA = ($a['confidence'] + $a['safety_score']) / 2;
            $scoreB = ($b['confidence'] + $b['safety_score']) / 2;
            return $scoreB <=> $scoreA;
        });

        return [
            'suggestions' => $suggestions,
            'total_providers' => count($validResults),
            'generation_time' => now()->toISOString(),
            'generation_id' => (string) Str::uuid(), // Add a trace ID for the entire generation event
        ];
    }

    /**
     * Calculate content confidence score
     */
    private function calculateConfidence(string $content): float
    {
        // Analyze content quality, coherence, and relevance
        $length = strlen($content);
        $wordCount = str_word_count($content);
        $sentenceCount = substr_count($content, '.') + substr_count($content, '!') + substr_count($content, '?');
        
        // Basic quality metrics
        $avgWordsPerSentence = $sentenceCount > 0 ? $wordCount / $sentenceCount : 0;
        $readabilityScore = $this->calculateReadabilityScore($content);
        
        // Combine metrics for confidence score
        $confidence = min(1.0, ($readabilityScore + $avgWordsPerSentence / 20) / 2);
        
        return max(0.0, min(1.0, $confidence));
    }

    /**
     * Calculate content safety score
     */
    private function calculateSafetyScore(string $content): float
    {
        // Use existing ContentModerationService
        $moderationService = app(ContentModerationService::class);
        $moderationResult = $moderationService->moderateContent($content);
        
        if ($moderationResult['flagged']) {
            return 0.0;
        }
        
        return 1.0 - max($moderationResult['categories'] ?? []);
    }

    /**
     * Get system prompt for different content types
     */
    private function getSystemPrompt(string $type): string
    {
        $prompts = [
            'profile' => 'You are an expert dating profile writer. Create engaging, authentic, and attractive profile content that helps users connect with potential matches.',
            'post_suggestions' => 'You are a social media content expert. Generate engaging, location-relevant bulletin board post suggestions that encourage community interaction.',
            'conversation_starters' => 'You are a conversation expert. Create interesting, personalized conversation starters that help users connect meaningfully.',
            'content_optimization' => 'You are a content optimization expert. Improve existing content for better engagement, clarity, and impact.',
        ];
        
        return $prompts[$type] ?? 'You are a helpful content generation assistant.';
    }

    /**
     * Build OpenAI prompt
     */
    private function buildOpenAIPrompt(array $context, array $additionalContext, string $type): string
    {
        $basePrompt = "Generate content based on the following context:\n\n";
        $basePrompt .= "Context: " . json_encode($context) . "\n";
        $basePrompt .= "Additional Context: " . json_encode($additionalContext) . "\n\n";
        
        switch ($type) {
            case 'profile':
                return $basePrompt . "Create an engaging dating profile bio that highlights the user's personality and interests. Make it authentic and appealing.";
            case 'post_suggestions':
                return $basePrompt . "Generate 5 engaging bulletin board post suggestions that are relevant to the location and community. Make them conversational and interactive.";
            case 'conversation_starters':
                return $basePrompt . "Create 3 personalized conversation starters that would work well in this context. Make them interesting and easy to respond to.";
            default:
                return $basePrompt . "Generate relevant, engaging content for this context.";
        }
    }

    /**
     * Build Gemini prompt
     */
    private function buildGeminiPrompt(array $context, array $additionalContext, string $type): string
    {
        $basePrompt = "Analyze this context and generate appropriate content:\n\n";
        $basePrompt .= "Context: " . json_encode($context) . "\n";
        $basePrompt .= "Additional Context: " . json_encode($additionalContext) . "\n\n";
        
        switch ($type) {
            case 'profile':
                return $basePrompt . "Write an attractive and authentic dating profile bio that showcases the user's personality and interests.";
            case 'post_suggestions':
                return $basePrompt . "Suggest 5 engaging bulletin board posts that would be relevant and interesting for this location and community.";
            case 'conversation_starters':
                return $basePrompt . "Create 3 conversation starters that would work well in this social context.";
            default:
                return $basePrompt . "Generate appropriate content for this context.";
        }
    }

    /**
     * Analyze user personality traits
     */
    private function analyzePersonalityTraits(User $user): array
    {
        // Analyze user's content and behavior to determine personality traits
        $messages = BulletinMessage::where('user_id', $user->id)->get();
        $content = $messages->pluck('content')->join(' ');
        
        // Basic personality analysis based on content
        $traits = [
            'extroversion' => $this->analyzeExtroversion($content),
            'openness' => $this->analyzeOpenness($content),
            'conscientiousness' => $this->analyzeConscientiousness($content),
            'agreeableness' => $this->analyzeAgreeableness($content),
            'neuroticism' => $this->analyzeNeuroticism($content),
        ];
        
        return $traits;
    }

    /**
     * Analyze communication style
     */
    private function analyzeCommunicationStyle(User $user): array
    {
        $messages = BulletinMessage::where('user_id', $user->id)->get();
        $content = $messages->pluck('content')->join(' ');
        
        return [
            'formality' => $this->analyzeFormality($content),
            'humor_usage' => $this->analyzeHumorUsage($content),
            'emoji_usage' => $this->analyzeEmojiUsage($content),
            'sentence_length' => $this->analyzeSentenceLength($content),
            'vocabulary_complexity' => $this->analyzeVocabularyComplexity($content),
        ];
    }

    /**
     * Calculate readability score
     */
    private function calculateReadabilityScore(string $content): float
    {
        $sentences = preg_split('/[.!?]+/', $content);
        $words = str_word_count($content);
        $syllables = $this->countSyllables($content);
        
        if (count($sentences) == 0 || $words == 0) {
            return 0.0;
        }
        
        $avgWordsPerSentence = $words / count($sentences);
        $avgSyllablesPerWord = $syllables / $words;
        
        // Flesch Reading Ease Score
        $score = 206.835 - (1.015 * $avgWordsPerSentence) - (84.6 * $avgSyllablesPerWord);
        
        return max(0.0, min(1.0, $score / 100));
    }

    /**
     * Count syllables in text
     */
    private function countSyllables(string $text): int
    {
        $words = str_word_count($text, 1);
        $syllables = 0;
        
        foreach ($words as $word) {
            $syllables += $this->countWordSyllables($word);
        }
        
        return $syllables;
    }

    /**
     * Count syllables in a single word
     */
    private function countWordSyllables(string $word): int
    {
        $word = strtolower($word);
        $syllables = 0;
        $vowels = 'aeiouy';
        $prevChar = '';
        
        for ($i = 0; $i < strlen($word); $i++) {
            $char = $word[$i];
            if (strpos($vowels, $char) !== false && strpos($vowels, $prevChar) === false) {
                $syllables++;
            }
            $prevChar = $char;
        }
        
        // Handle silent 'e'
        if (substr($word, -1) === 'e' && $syllables > 1) {
            $syllables--;
        }
        
        return max(1, $syllables);
    }

    /**
     * Calculate distance between two points
     */
    private function calculateDistance(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $earthRadius = 6371000; // meters
        
        $dLat = deg2rad($lat2 - $lat1);
        $dLon = deg2rad($lon2 - $lon1);
        
        $a = sin($dLat/2) * sin($dLat/2) + cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * sin($dLon/2) * sin($dLon/2);
        $c = 2 * atan2(sqrt($a), sqrt(1-$a));
        
        return $earthRadius * $c;
    }

    // Personality analysis methods (simplified implementations)
    private function analyzeExtroversion(string $content): float { 
        $extroversionWords = ['party', 'social', 'friends', 'group', 'together', 'fun', 'excited'];
        $score = 0;
        foreach ($extroversionWords as $word) {
            $score += substr_count(strtolower($content), $word);
        }
        return min(1.0, $score / 10);
    }
    
    private function analyzeOpenness(string $content): float { 
        $opennessWords = ['creative', 'art', 'music', 'travel', 'new', 'different', 'explore'];
        $score = 0;
        foreach ($opennessWords as $word) {
            $score += substr_count(strtolower($content), $word);
        }
        return min(1.0, $score / 10);
    }
    
    private function analyzeConscientiousness(string $content): float { 
        $conscientiousnessWords = ['plan', 'organize', 'goal', 'work', 'study', 'responsible'];
        $score = 0;
        foreach ($conscientiousnessWords as $word) {
            $score += substr_count(strtolower($content), $word);
        }
        return min(1.0, $score / 10);
    }
    
    private function analyzeAgreeableness(string $content): float { 
        $agreeablenessWords = ['help', 'kind', 'nice', 'support', 'care', 'love', 'compassion'];
        $score = 0;
        foreach ($agreeablenessWords as $word) {
            $score += substr_count(strtolower($content), $word);
        }
        return min(1.0, $score / 10);
    }
    
    private function analyzeNeuroticism(string $content): float { 
        $neuroticismWords = ['worry', 'anxious', 'stress', 'nervous', 'upset', 'sad'];
        $score = 0;
        foreach ($neuroticismWords as $word) {
            $score += substr_count(strtolower($content), $word);
        }
        return min(1.0, $score / 10);
    }
    
    private function analyzeFormality(string $content): float { 
        $formalWords = ['please', 'thank you', 'sincerely', 'regards', 'respectfully'];
        $informalWords = ['hey', 'yo', 'lol', 'omg', 'btw', 'tbh'];
        
        $formalCount = 0;
        $informalCount = 0;
        
        foreach ($formalWords as $word) {
            $formalCount += substr_count(strtolower($content), $word);
        }
        
        foreach ($informalWords as $word) {
            $informalCount += substr_count(strtolower($content), $word);
        }
        
        $total = $formalCount + $informalCount;
        return $total > 0 ? $formalCount / $total : 0.5;
    }
    
    private function analyzeHumorUsage(string $content): float { 
        $humorIndicators = ['lol', 'haha', 'funny', 'joke', 'laugh', '😄', '😂', '🤣'];
        $score = 0;
        foreach ($humorIndicators as $indicator) {
            $score += substr_count(strtolower($content), $indicator);
        }
        return min(1.0, $score / 5);
    }
    
    private function analyzeEmojiUsage(string $content): float { 
        $emojiCount = preg_match_all('/[\x{1F600}-\x{1F64F}]|[\x{1F300}-\x{1F5FF}]|[\x{1F680}-\x{1F6FF}]|[\x{1F1E0}-\x{1F1FF}]|[\x{2600}-\x{26FF}]|[\x{2700}-\x{27BF}]/u', $content);
        $wordCount = str_word_count($content);
        return $wordCount > 0 ? min(1.0, $emojiCount / $wordCount) : 0;
    }
    
    private function analyzeSentenceLength(string $content): float { 
        $sentences = preg_split('/[.!?]+/', $content);
        $words = str_word_count($content);
        $sentenceCount = count(array_filter($sentences));
        
        if ($sentenceCount == 0) return 0.5;
        
        $avgWordsPerSentence = $words / $sentenceCount;
        return min(1.0, $avgWordsPerSentence / 20); // Normalize to 20 words per sentence
    }
    
    private function analyzeVocabularyComplexity(string $content): float { 
        $words = str_word_count($content, 1);
        $complexWords = 0;
        
        foreach ($words as $word) {
            if (strlen($word) > 6) { // Words longer than 6 characters
                $complexWords++;
            }
        }
        
        $totalWords = count($words);
        return $totalWords > 0 ? min(1.0, $complexWords / $totalWords) : 0;
    }
    
    private function calculateActivityLevel(User $user): float { 
        $messageCount = BulletinMessage::where('user_id', $user->id)->count();
        $daysSinceJoined = $user->created_at->diffInDays(now());
        
        return $daysSinceJoined > 0 ? min(1.0, $messageCount / $daysSinceJoined) : 0;
    }
    
    private function analyzeEngagementPatterns(User $user): array { 
        return [
            'peak_hours' => [],
            'content_types' => [],
            'interaction_style' => 'balanced',
        ];
    }
    
    private function getRecentBoardActivity(BulletinBoard $board): array { 
        return BulletinMessage::where('bulletin_board_id', $board->id)
            ->where('created_at', '>=', now()->subDays(7))
            ->count();
    }
    
    private function getPopularBoardTopics(BulletinBoard $board): array { 
        return [];
    }
    
    private function getBoardUserDemographics(BulletinBoard $board): array { 
        return [];
    }
}
</UPDATED_EXISTING_FILE>

<UPDATED_EXISTING_FILE: app/Http/Controllers/ContentGenerationController.php>
<?php

namespace App\Http\Controllers;

use App\Services\ContentGenerationService;
use App\Services\ContentOptimizationService;
use App\Models\User;
use App\Models\BulletinBoard;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Log;

class ContentGenerationController extends Controller
{
    protected ContentGenerationService $contentGenerationService;
    protected ContentOptimizationService $contentOptimizationService;

    public function __construct(
        ContentGenerationService $contentGenerationService,
        ContentOptimizationService $contentOptimizationService
    ) {
        $this->contentGenerationService = $contentGenerationService;
        $this->contentOptimizationService = $contentOptimizationService;
    }

    /**
     * Generate profile content for the authenticated user
     */
    public function generateProfileContent(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'personality' => 'nullable|string|max:255',
            'interests' => 'nullable|array',
            'interests.*' => 'string|max:255',
            'goals' => 'nullable|string|max:1000',
            'style' => 'nullable|string|in:casual,professional,humorous,romantic',
            'target_audience' => 'nullable|string|max:255',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'error' => 'Validation failed',
                'messages' => $validator->errors()
            ], 400);
        }

        $user = Auth::user();
        $preferences = $request->only([
            'personality', 'interests', 'goals', 'style', 'target_audience'
        ]);

        try {
            $result = $this->contentGenerationService->generateProfileContent($user, $preferences);
            
            return response()->json([
                'success' => true,
                'data' => $result,
                'user_id' => $user->id,
                'generated_at' => now()->toISOString(),
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Content generation failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Generate post suggestions for a bulletin board
     */
    public function generatePostSuggestions(Request $request, int $boardId): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'context' => 'nullable|array',
            'context.location' => 'nullable|array',
            'context.time' => 'nullable|string',
            'context.topics' => 'nullable|array',
            'context.topics.*' => 'string|max:255',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'error' => 'Validation failed',
                'messages' => $validator->errors()
            ], 400);
        }

        $user = Auth::user();
        $board = BulletinBoard::find($boardId);

        if (!$board) {
            return response()->json([
                'error' => 'Bulletin board not found'
            ], 404);
        }

        $context = $request->input('context', []);

        try {
            $result = $this->contentGenerationService->generatePostSuggestions($board, $user, $context);
            
            return response()->json([
                'success' => true,
                'data' => $result,
                'board_id' => $boardId,
                'user_id' => $user->id,
                'generated_at' => now()->toISOString(),
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Post suggestions generation failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Generate conversation starters
     */
    public function generateConversationStarters(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'context' => 'nullable|array',
            'context.type' => 'nullable|string|in:general,romantic,casual,professional',
            'context.target_user' => 'nullable|array',
            'context.previous_messages' => 'nullable|array',
            'context.hints' => 'nullable|array',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'error' => 'Validation failed',
                'messages' => $validator->errors()
            ], 400);
        }

        $user = Auth::user();
        $context = $request->input('context', []);

        try {
            $result = $this->contentGenerationService->generateConversationStarters($user, $context);
            
            return response()->json([
                'success' => true,
                'data' => $result,
                'user_id' => $user->id,
                'generated_at' => now()->toISOString(),
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Conversation starters generation failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Optimize content for better engagement, clarity, safety, and relevance
     */
    public function optimizeContent(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'content' => 'required|string|max:2000',
            'context' => 'nullable|array',
            'optimization_types' => 'nullable|array',
            'optimization_types.*' => 'string|in:engagement,clarity,safety,relevance',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'error' => 'Validation failed',
                'messages' => $validator->errors()
            ], 400);
        }

        $content = $request->input('content');
        $context = $request->input('context', []);
        $optimizationTypes = $request->input('optimization_types', ['engagement', 'clarity', 'safety', 'relevance']);

        try {
            $result = $this->contentOptimizationService->optimizeContent($content, $context);
            
            // Filter results based on requested optimization types
            if (!empty($optimizationTypes)) {
                $filteredImprovements = [];
                foreach ($optimizationTypes as $type) {
                    if (isset($result['improvements'][$type])) {
                        $filteredImprovements[$type] = $result['improvements'][$type];
                    }
                }
                $result['improvements'] = $filteredImprovements;
            }
            
            return response()->json([
                'success' => true,
                'data' => $result,
                'user_id' => Auth::id(),
                'optimized_at' => now()->toISOString(),
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Content optimization failed',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get content generation statistics
     */
    public function getGenerationStats(): JsonResponse
    {
        try {
            $stats = [
                'total_generations' => 0, // This would come from a database query
                'successful_generations' => 0,
                'failed_generations' => 0,
                'average_generation_time' => 0,
                'most_popular_types' => [],
                'user_satisfaction' => 0,
                'generated_at' => now()->toISOString(),
            ];

            return response()->json([
                'success' => true,
                'data' => $stats,
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Failed to retrieve generation statistics',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get content optimization statistics
     */
    public function getOptimizationStats(): JsonResponse
    {
        try {
            $stats = [
                'total_optimizations' => 0, // This would come from a database query
                'successful_optimizations' => 0,
                'failed_optimizations' => 0,
                'average_improvement_score' => 0,
                'most_common_improvements' => [],
                'optimization_types_usage' => [],
                'generated_at' => now()->toISOString(),
            ];

            return response()->json([
                'success' => true,
                'data' => $stats,
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Failed to retrieve optimization statistics',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Provide feedback on generated content
     */
    public function submitContentFeedback(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'suggestion_id' => 'required|string|uuid',
            'content_type' => 'required|string|in:profile,post_suggestion,conversation_starter',
            'rating' => 'required|integer|min:1|max:5',
            'feedback' => 'nullable|string|max:1000',
            'improvements' => 'nullable|array',
            'improvements.*' => 'string|max:255',
        ]);

        if ($validator->fails()) {
            return response()->json([
                'error' => 'Validation failed',
                'messages' => $validator->errors()
            ], 400);
        }

        $user = Auth::user();
        $feedbackData = $request->only([
            'suggestion_id', 'content_type', 'rating', 'feedback', 'improvements'
        ]);

        try {
            // Store feedback in database (this would be implemented)
            // For now, just log the feedback
            Log::info('Content feedback received', [
                'user_id' => $user->id,
                'feedback' => $feedbackData
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Feedback submitted successfully',
                'feedback_id' => uniqid('feedback_'),
                'submitted_at' => now()->toISOString(),
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Failed to submit feedback',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get user's content generation history
     */
    public function getGenerationHistory(Request $request): JsonResponse
    {
        $user = Auth::user();
        $page = $request->input('page', 1);
        $perPage = $request->input('per_page', 10);

        try {
            // This would query the database for user's generation history
            $history = [
                'generations' => [],
                'pagination' => [
                    'current_page' => $page,
                    'per_page' => $perPage,
                    'total' => 0,
                    'has_more' => false,
                ],
                'generated_at' => now()->toISOString(),
            ];

            return response()->json([
                'success' => true,
                'data' => $history,
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Failed to retrieve generation history',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Delete generated content
     */
    public function deleteGeneratedContent(Request $request, string $contentId): JsonResponse
    {
        $user = Auth::user();

        try {
            // This would delete the content from the database
            // For now, just return success
            return response()->json([
                'success' => true,
                'message' => 'Content deleted successfully',
                'content_id' => $contentId,
                'deleted_at' => now()->toISOString(),
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Failed to delete content',
                'message' => $e->getMessage()
            ], 500);
        }
    }
}
</UPDATED_EXISTING_FILE>

<UPDATED_EXISTING_FILE: components/AIProfileBuilder.tsx>
"use client";

import { useState } from 'react';
import { useProfileContentGeneration, useContentFeedback } from '@/lib/hooks/use-content-generation';
import { useAuth } from '@/lib/auth-context';

interface AIProfileBuilderProps {
  onProfileGenerated?: (profile: any) => void;
  initialPreferences?: {
    personality?: string;
    interests?: string[];
    goals?: string;
    style?: string;
    target_audience?: string;
  };
}

export default function AIProfileBuilder({ 
  onProfileGenerated,
  initialPreferences = {}
}: AIProfileBuilderProps) {
  const [preferences, setPreferences] = useState({
    personality: initialPreferences.personality || '',
    interests: initialPreferences.interests || [],
    goals: initialPreferences.goals || '',
    style: initialPreferences.style || 'casual',
    target_audience: initialPreferences.target_audience || '',
  });
  
  const [selectedContent, setSelectedContent] = useState<string>('');
  const [isGenerating, setIsGenerating] = useState(false);
  
  const { user } = useAuth();
  const { data: generatedContent, isLoading, error, refetch } = useProfileContentGeneration(preferences);
  const feedbackMutation = useContentFeedback();

  const handleGenerateProfile = async () => {
    setIsGenerating(true);
    try {
      await refetch();
    } finally {
      setIsGenerating(false);
    }
  };

  const handleContentSelect = (content: string) => {
    setSelectedContent(content);
    if (onProfileGenerated) {
      onProfileGenerated({
        content,
        preferences,
        generated_at: new Date().toISOString(),
      });
    }
  };

  const handleFeedback = async (suggestionId: string, rating: number, feedback?: string) => {
    try {
      await feedbackMutation.mutateAsync({
        suggestion_id: suggestionId,
        content_type: 'profile',
        rating,
        feedback,
      });
      // Optionally show a "Thanks for your feedback!" message
    } catch (error) {
      console.error('Feedback submission failed:', error);
    }
  };

  const personalityTypes = [
    { value: 'extroverted', label: 'Extroverted & Social', description: 'Outgoing and energetic' },
    { value: 'introverted', label: 'Introverted & Thoughtful', description: 'Reflective and deep' },
    { value: 'adventurous', label: 'Adventurous & Spontaneous', description: 'Love new experiences' },
    { value: 'analytical', label: 'Analytical & Logical', description: 'Thoughtful and methodical' },
    { value: 'creative', label: 'Creative & Artistic', description: 'Imaginative and expressive' },
    { value: 'athletic', label: 'Athletic & Active', description: 'Sports and fitness focused' },
  ];

  const interestOptions = [
    'Travel', 'Music', 'Sports', 'Art', 'Technology', 'Food', 'Fitness', 'Reading',
    'Movies', 'Gaming', 'Photography', 'Cooking', 'Dancing', 'Hiking', 'Yoga', 'Writing'
  ];

  const styleOptions = [
    { value: 'casual', label: 'Casual', description: 'Relaxed and friendly' },
    { value: 'professional', label: 'Professional', description: 'Formal and business-like' },
    { value: 'humorous', label: 'Humorous', description: 'Funny and light-hearted' },
    { value: 'romantic', label: 'Romantic', description: 'Sweet and affectionate' },
  ];

  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="text-center mb-8">
        <h1 className="text-4xl font-bold text-gray-900 mb-2">AI-Powered Profile Builder</h1>
        <p className="text-gray-600">Let AI help you create an engaging and authentic profile</p>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Preferences Form */}
        <div className="space-y-6">
          <div className="bg-white p-6 rounded-lg shadow-md">
            <h2 className="text-xl font-semibold mb-4 text-gray-800">Tell us about yourself</h2>
            
            {/* Personality Type */}
            <div className="mb-6">
              <label className="block text-sm font-medium mb-3 text-gray-700">Personality Type</label>
              <div className="grid grid-cols-1 gap-3">
                {personalityTypes.map(type => (
                  <label key={type.value} className="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50">
                    <input
                      type="radio"
                      name="personality"
                      value={type.value}
                      checked={preferences.personality === type.value}
                      onChange={(e) => setPreferences(prev => ({ ...prev, personality: e.target.value }))}
                      className="mt-1"
                    />
                    <div>
                      <div className="font-medium text-gray-900">{type.label}</div>
                      <div className="text-sm text-gray-600">{type.description}</div>
                    </div>
                  </label>
                ))}
              </div>
            </div>

            {/* Interests */}
            <div className="mb-6">
              <label className="block text-sm font-medium mb-3 text-gray-700">Interests</label>
              <div className="grid grid-cols-2 gap-2">
                {interestOptions.map(interest => (
                  <label key={interest} className="flex items-center space-x-2 p-2 border border-gray-200 rounded cursor-pointer hover:bg-gray-50">
                    <input
                      type="checkbox"
                      checked={preferences.interests.includes(interest)}
                      onChange={(e) => {
                        if (e.target.checked) {
                          setPreferences(prev => ({
                            ...prev,
                            interests: [...prev.interests, interest]
                          }));
                        } else {
                          setPreferences(prev => ({
                            ...prev,
                            interests: prev.interests.filter(i => i !== interest)
                          }));
                        }
                      }}
                    />
                    <span className="text-sm text-gray-700">{interest}</span>
                  </label>
                ))}
              </div>
            </div>

            {/* Goals */}
            <div className="mb-6">
              <label className="block text-sm font-medium mb-2 text-gray-700">What are you looking for?</label>
              <textarea
                value={preferences.goals}
                onChange={(e) => setPreferences(prev => ({ ...prev, goals: e.target.value }))}
                placeholder="Describe what you're looking for in a relationship..."
                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                rows={3}
              />
            </div>

            {/* Writing Style */}
            <div className="mb-6">
              <label className="block text-sm font-medium mb-3 text-gray-700">Writing Style</label>
              <div className="grid grid-cols-2 gap-3">
                {styleOptions.map(style => (
                  <label key={style.value} className="flex items-start space-x-3 p-3 border border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50">
                    <input
                      type="radio"
                      name="style"
                      value={style.value}
                      checked={preferences.style === style.value}
                      onChange={(e) => setPreferences(prev => ({ ...prev, style: e.target.value }))}
                      className="mt-1"
                    />
                    <div>
                      <div className="font-medium text-gray-900">{style.label}</div>
                      <div className="text-sm text-gray-600">{style.description}</div>
                    </div>
                  </label>
                ))}
              </div>
            </div>

            {/* Target Audience */}
            <div className="mb-6">
              <label className="block text-sm font-medium mb-2 text-gray-700">Target Audience</label>
              <input
                type="text"
                value={preferences.target_audience}
                onChange={(e) => setPreferences(prev => ({ ...prev, target_audience: e.target.value }))}
                placeholder="Who do you want to attract?"
                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>

            {/* Generate Button */}
            <button
              onClick={handleGenerateProfile}
              disabled={isGenerating || isLoading}
              className="w-full bg-blue-500 text-white py-3 px-6 rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
            >
              {isGenerating || isLoading ? 'Generating Profile...' : 'Generate AI Profile'}
            </button>
          </div>
        </div>

        {/* Generated Content */}
        <div className="space-y-6">
          {error && (
            <div className="bg-red-50 p-4 rounded-lg">
              <h3 className="font-semibold text-red-800 mb-2">Generation Failed</h3>
              <p className="text-sm text-red-700">
                {error.message || 'An error occurred while generating your profile.'}
              </p>
            </div>
          )}

          {generatedContent && (
            <div className="bg-white p-6 rounded-lg shadow-md">
              <h2 className="text-xl font-semibold mb-4 text-gray-800">Generated Profile Content</h2>
              <div className="space-y-4">
                {generatedContent.data?.suggestions?.map((suggestion: any, index: number) => (
                  <div key={suggestion.id || index} className="p-4 border border-gray-200 rounded-lg">
                    <div className="flex justify-between items-start mb-2">
                      <div className="flex items-center space-x-2">
                        <span className="text-sm font-medium text-gray-600">
                          {suggestion.provider === 'openai' ? 'OpenAI' : 'Gemini'}
                        </span>
                        <span className="text-xs text-gray-500">
                          Confidence: {Math.round(suggestion.confidence * 100)}%
                        </span>
                        <span className="text-xs text-green-600">
                          Safety: {Math.round(suggestion.safety_score * 100)}%
                        </span>
                      </div>
                      <button
                        onClick={() => handleContentSelect(suggestion.content)}
                        className={`px-3 py-1 text-sm rounded ${
                          selectedContent === suggestion.content
                            ? 'bg-blue-500 text-white'
                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                        }`}
                      >
                        {selectedContent === suggestion.content ? 'Selected' : 'Select'}
                      </button>
                    </div>
                    <p className="text-sm text-gray-700 mb-3">{suggestion.content}</p>
                    <div className="flex space-x-2">
                      {[1, 2, 3, 4, 5].map(rating => (
                        <button
                          key={rating}
                          onClick={() => handleFeedback(suggestion.id, rating)}
                          className="text-yellow-400 hover:text-yellow-500 text-lg"
                        >
                          ★
                        </button>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {selectedContent && (
            <div className="bg-green-50 p-4 rounded-lg">
              <h3 className="font-semibold text-green-800 mb-2">Selected Profile</h3>
              <p className="text-sm text-green-700 mb-3">{selectedContent}</p>
              <button
                onClick={() => setSelectedContent('')}
                className="text-sm text-green-600 hover:text-green-800"
              >
                Change Selection
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</UPDATED_EXISTING_FILE>
</GENERATED-CODE>
